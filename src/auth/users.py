from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, Response, Request
from starlette.responses import JSONResponse
from src.models import Company
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.exc import SQLAlchemyError
from src.models import User, Employee
from starlette import status
from src.schemas import CompanyCreate, CompanyRead, CompanyUpdate
from sqlalchemy import select, update
from starlette import status
from fastapi_cache.decorator import cache as cache_decorator
from fastapi_redis_cache import cache_one_minute
from src.custom_responses import *
from src.db import get_async_session
from datetime import datetime as dt

from fastapi.security import OAuth2PasswordBearer

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/bearer/token")


users_router = APIRouter(prefix="/auth",
    responses=ROUTER_API_RESPONSES_OPEN_API
)
# Bearer router
bearer_router = APIRouter(prefix="/bearer",
    responses=ROUTER_API_RESPONSES_OPEN_API
)

user_crud = APIRouter(prefix="/users",
    responses=ROUTER_API_RESPONSES_OPEN_API
)

user_oauth_outer = APIRouter(prefix="/oauth-outer",
    responses=ROUTER_API_RESPONSES_OPEN_API
)




# Temp Mock users         <<<<<<<    M O C K I N G   U S E R S : I'll delete these
active_user = User(
    full_name="Ivan Goncharov",
    email="ivan.stereotekk@gmail.com",
    phone="89855203082",
    picture='bla-bla-bla',
    birth_date=dt.now,
    hashed_password='somepass',
    is_active=True,
    is_superuser=True,
    is_verified=True,
)

def current_active_user():
    return active_user

superuser = User(
    full_name="Second User Good Guy",
    email="testmail@gmail.com",
    phone="898554556633",
    picture='bla-bla-bla',
    birth_date=dt.now,
    hashed_password='somepass',
    is_active=True,
    is_superuser=True,
    is_verified=True,
)

def current_superuser():
    return superuser






#                                <<<<<<    U S E R S    R O U T E R
@users_router.post('/registration')
async def registration():
    pass

@users_router.post('/login')
async def login():
    pass

@users_router.get('/logout')
async def logout(token:Annotated[str,Depends(oauth2_scheme)]):
    pass

@users_router.post('/forgot-password')
async def forgot_password(email:str):
    return f"forgot password {email}"
#             <<<<<    PASSWORD AND VERIFICATION HANDLERS
@users_router.post('/reset-password')
async def reset_password(email:str):
    return f"The logic that resets password ..makes url that sendig on {email}"
@users_router.post('/request-verify')
async def request_verify():
    """Verify router¶
POST /request-verify-token¶
Request a user to verify their e-mail. Will generate a temporary token and call the on_after_request_verify handler if the user exists, active and not already verified.
To prevent malicious users from guessing existing users in your database, the route will always return a 202 Accepted response, even if the user requested does not exist, not active or already verified."""
    return {"method": 'Request-verify'}
@users_router.post('/verify')
async def verify():
    """Verify a user. 
    Requires the token generated by the /request-verify-token route.
    Will call the call the on_after_verify handler on success.
    """
    return {"method": 'Verify'}

#                          <<<<<    B E A R E R      T R A N S P O R T     VERIFY / REFRESH
@bearer_router.post('/token-verify')
async def verify_token(token:Annotated[str,Depends(oauth2_scheme)]):
    """This guy should work fine with two things to get a token so if it happens that token is obsolete it shoud do renew under the hood"""
    pass

@bearer_router.post('/refresh')
async def refresh_token(token:Annotated[str,Depends(oauth2_scheme)]):
    return token


#                     <<<< Typical User CRUD Methods 
@user_crud.get('/me')
async def retrieve_me(token:Annotated[str,Depends(oauth2_scheme)]):
    return current_active_user

@user_crud.patch('/patch')
async def patch_me(token:Annotated[str,Depends(oauth2_scheme)]):
    return " Ok "

@user_crud.get('/{user_id}')
async def retrive_by_id(token:Annotated[str,Depends(oauth2_scheme)]):
    return current_active_user


@user_crud.patch('/patch/{user_id}')
async def patch_by_id(token:Annotated[str,Depends(oauth2_scheme)]): # SUPERUSER CAN
    return " Ok "

@user_crud.delete('/delete/{user_id}')
async def delete_by_id(token:Annotated[str,Depends(oauth2_scheme)]):
    return " Ok "





#                <<<<<<<<        Some outer Service (Google)    - O P T I O N A L
@user_oauth_outer.get('/authorize')
async def authorize_url():
    """OPTIONAL"""
    return {
    "authorization_url": "Authorization URL for the OAuth service where you should redirect your user"
}

@user_oauth_outer.get('/callback')
async def oauth_handler():
    """OPTIONAL"""
    return {
    "detail": "OAUTH_USER_ALREADY_EXISTS"
}
